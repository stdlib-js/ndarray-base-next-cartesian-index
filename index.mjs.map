{"version":3,"file":"index.mjs","sources":["../lib/assign.js","../lib/main.js","../lib/index.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// VARIABLES //\n\nvar ROW_MAJOR = 'row-major';\n\n\n// FUNCTIONS //\n\n/**\n* Returns the next Cartesian index (row-major).\n*\n* @private\n* @param {NonNegativeInteger} ndims - number of dimensions\n* @param {NonNegativeIntegerArray} shape - array shape\n* @param {NonNegativeIntegerArray} idx - current dimension indices\n* @param {NonNegativeInteger} dim - index of the dimension from which to start incrementing (inclusive)\n* @param {(Array|TypedArray|Object)} out - output array\n* @returns {(Array|TypedArray|Object)} output array\n*/\nfunction rowmajor( ndims, shape, idx, dim, out ) {\n\tvar i;\n\tvar j;\n\n\t// Set dimension indices which are skipped...\n\tfor ( i = ndims-1; i > dim; i-- ) {\n\t\tout[ i ] = idx[ i ];\n\t}\n\t// Search for the first dimension in which we don't have to \"carry the one\"...\n\tfor ( i = dim; i >= 0; i-- ) {\n\t\tj = ( idx[ i ] + 1 ) % shape[ i ];\n\t\tout[ i ] = j;\n\n\t\t// If the current index value is greater than zero, we can continue iterating within the current sub-array...\n\t\tif ( j > 0 ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t// Set dimension indices which did not get updated...\n\tfor ( i -= 1; i >= 0; i-- ) {\n\t\tout[ i ] = idx[ i ];\n\t}\n\treturn out;\n}\n\n/**\n* Returns the next Cartesian index (column-major).\n*\n* @private\n* @param {NonNegativeInteger} ndims - number of dimensions\n* @param {NonNegativeIntegerArray} shape - array shape\n* @param {NonNegativeIntegerArray} idx - current dimension indices\n* @param {NonNegativeInteger} dim - index of the dimension from which to start incrementing (inclusive)\n* @param {(Array|TypedArray|Object)} out - output array\n* @returns {(Array|TypedArray|Object)} output array\n*/\nfunction columnmajor( ndims, shape, idx, dim, out ) {\n\tvar i;\n\tvar j;\n\n\t// Set dimension indices which are skipped...\n\tfor ( i = 0; i < dim; i++ ) {\n\t\tout[ i ] = idx[ i ];\n\t}\n\t// Search for the first dimension in which we don't have to \"carry the one\"...\n\tfor ( i = dim; i < ndims; i++ ) {\n\t\tj = ( idx[ i ] + 1 ) % shape[ i ];\n\t\tout[ i ] = j;\n\n\t\t// If the current index value is greater than zero, we can continue iterating within the current sub-array...\n\t\tif ( j > 0 ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t// Set dimension indices which did not get updated...\n\tfor ( i += 1; i < ndims; i++ ) {\n\t\tout[ i ] = idx[ i ];\n\t}\n\treturn out;\n}\n\n\n// MAIN //\n\n/**\n* Returns the next Cartesian index (i.e., set of subscripts/dimension indices) and assigns results to a provided output array.\n*\n* ## Notes\n*\n* -   The function does not check whether the current index is the \"last\" index. Instead, if the function is provided dimension indices corresponding to the last element, the function will cycle back to the \"first\" index.\n*\n* @param {NonNegativeIntegerArray} shape - array shape\n* @param {string} order - index iteration order\n* @param {NonNegativeIntegerArray} idx - current dimension indices\n* @param {integer} dim - index of the dimension from which to start incrementing (inclusive)\n* @param {(Array|TypedArray|Object)} out - output array\n* @returns {(Array|TypedArray|Object|null)} output array (or null)\n*\n* @example\n* var shape = [ 12 ];\n* var idx = nextCartesianIndex( shape, 'row-major', [ 2 ], 0, [ 0 ] );\n* // returns [ 3 ]\n*\n* @example\n* var shape = [ 2, 2, 2 ];\n*\n* var out = [ 0, 0, 0 ];\n* var idx = nextCartesianIndex( shape, 'row-major', [ 0, 0, 1 ], -1, out );\n* // returns [ 0, 1, 0 ]\n*\n* idx = nextCartesianIndex( shape, 'row-major', idx, -1, out );\n* // returns [ 0, 1, 1 ]\n*\n* idx = nextCartesianIndex( shape, 'row-major', idx, -1, out );\n* // returns [ 1, 0, 0 ]\n*\n* idx = nextCartesianIndex( shape, 'row-major', idx, -1, out );\n* // returns [ 1, 0, 1 ]\n*\n* idx = nextCartesianIndex( shape, 'row-major', idx, -1, out );\n* // returns [ 1, 1, 0 ]\n*\n* idx = nextCartesianIndex( shape, 'row-major', idx, -1, out );\n* // returns [ 1, 1, 1 ]\n*\n* @example\n* var shape = [];\n* var idx = nextCartesianIndex( shape, 'row-major', [], 0, [] );\n* // returns null\n*\n* @example\n* var shape = [ 12 ];\n* var idx = nextCartesianIndex( shape, 'row-major', [ 2 ], -10, [ 0 ] );\n* // returns null\n*\n* @example\n* var shape = [ 12 ];\n* var idx = nextCartesianIndex( shape, 'column-major', [ 2 ], 10, [ 0 ] );\n* // returns null\n*/\nfunction nextCartesianIndex( shape, order, idx, dim, out ) {\n\tvar ndims = shape.length;\n\tif ( ndims === 0 ) {\n\t\treturn null;\n\t}\n\tif ( dim < 0 ) {\n\t\tdim += ndims;\n\t\tif ( dim < 0 ) {\n\t\t\t// Out-of-bounds:\n\t\t\treturn null;\n\t\t}\n\t} else if ( dim >= ndims ) {\n\t\t// Out-of-bounds:\n\t\treturn null;\n\t}\n\tif ( order === ROW_MAJOR ) {\n\t\treturn rowmajor( ndims, shape, idx, dim, out );\n\t}\n\t// order === 'column-major'\n\treturn columnmajor( ndims, shape, idx, dim, out );\n}\n\n\n// EXPORTS //\n\nexport default nextCartesianIndex;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport zeros from '@stdlib/array-base-zeros';\nimport assign from './assign.js';\n\n\n// MAIN //\n\n/**\n* Returns the next Cartesian index (i.e., set of subscripts/dimension indices).\n*\n* ## Notes\n*\n* -   The function does not check whether the current index is the \"last\" index. Instead, if the function is provided dimension indices corresponding to the last element, the function will cycle back to the \"first\" index.\n*\n* @param {NonNegativeIntegerArray} shape - array shape\n* @param {string} order - index iteration order\n* @param {NonNegativeIntegerArray} idx - current dimension indices\n* @param {integer} dim - index of the dimension from which to start incrementing (inclusive)\n* @returns {(NonNegativeIntegerArray|null)} updated dimension indices\n*\n* @example\n* var shape = [ 12 ];\n* var idx = nextCartesianIndex( shape, 'row-major', [ 2 ], 0 );\n* // returns [ 3 ]\n*\n* @example\n* var shape = [ 2, 2, 2 ];\n*\n* var idx = nextCartesianIndex( shape, 'row-major', [ 0, 0, 1 ], -1 );\n* // returns [ 0, 1, 0 ]\n*\n* idx = nextCartesianIndex( shape, 'row-major', idx, -1 );\n* // returns [ 0, 1, 1 ]\n*\n* idx = nextCartesianIndex( shape, 'row-major', idx, -1 );\n* // returns [ 1, 0, 0 ]\n*\n* idx = nextCartesianIndex( shape, 'row-major', idx, -1 );\n* // returns [ 1, 0, 1 ]\n*\n* idx = nextCartesianIndex( shape, 'row-major', idx, -1 );\n* // returns [ 1, 1, 0 ]\n*\n* idx = nextCartesianIndex( shape, 'row-major', idx, -1 );\n* // returns [ 1, 1, 1 ]\n*\n* @example\n* var shape = [];\n* var idx = nextCartesianIndex( shape, 'row-major', [], 0 );\n* // returns null\n*\n* @example\n* var shape = [ 12 ];\n* var idx = nextCartesianIndex( shape, 'row-major', [ 2 ], -10 );\n* // returns null\n*\n* @example\n* var shape = [ 12 ];\n* var idx = nextCartesianIndex( shape, 'column-major', [ 2 ], 10 );\n* // returns null\n*/\nfunction nextCartesianIndex( shape, order, idx, dim ) {\n\treturn assign( shape, order, idx, dim, zeros( shape.length ) );\n}\n\n\n// EXPORTS //\n\nexport default nextCartesianIndex;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Return the next Cartesian index (i.e., set of subscripts/dimension indices).\n*\n* @module @stdlib/ndarray-base-next-cartesian-index\n*\n* @example\n* import nextCartesianIndex from '@stdlib/ndarray-base-next-cartesian-index';\n*\n* var shape = [ 2, 2, 2 ];\n*\n* var idx = nextCartesianIndex( shape, 'row-major', [ 0, 0, 1 ], -1 );\n* // returns [ 0, 1, 0 ]\n*\n* idx = nextCartesianIndex( shape, 'row-major', idx, -1 );\n* // returns [ 0, 1, 1 ]\n*\n* idx = nextCartesianIndex( shape, 'row-major', idx, -1 );\n* // returns [ 1, 0, 0 ]\n*\n* idx = nextCartesianIndex( shape, 'row-major', idx, -1 );\n* // returns [ 1, 0, 1 ]\n*\n* idx = nextCartesianIndex( shape, 'row-major', idx, -1 );\n* // returns [ 1, 1, 0 ]\n*\n* idx = nextCartesianIndex( shape, 'row-major', idx, -1 );\n* // returns [ 1, 1, 1 ]\n*/\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils-define-nonenumerable-read-only-property';\nimport main from './main.js';\nimport assign from './assign.js';\n\n\n// MAIN //\n\nsetReadOnly( main, 'assign', assign );\n\n\n// EXPORTS //\n\nexport default main;\n"],"names":["ROW_MAJOR","nextCartesianIndex","shape","order","idx","dim","out","ndims","length","i","j","rowmajor","columnmajor","assign","zeros","setReadOnly","main"],"mappings":";;mNAsBA,IAAIA,EAAY,YAwIhB,SAASC,EAAoBC,EAAOC,EAAOC,EAAKC,EAAKC,GACpD,IAAIC,EAAQL,EAAMM,OAClB,GAAe,IAAVD,EACJ,OAAO,KAER,GAAKF,EAAM,GAEV,IADAA,GAAOE,GACI,EAEV,OAAO,UAEF,GAAKF,GAAOE,EAElB,OAAO,KAER,OAAKJ,IAAUH,EAvIhB,SAAmBO,EAAOL,EAAOE,EAAKC,EAAKC,GAC1C,IAAIG,EACAC,EAGJ,IAAMD,EAAIF,EAAM,EAAGE,EAAIJ,EAAKI,IAC3BH,EAAKG,GAAML,EAAKK,GAGjB,IAAMA,EAAIJ,EAAKI,GAAK,IACnBC,GAAMN,EAAKK,GAAM,GAAMP,EAAOO,GAC9BH,EAAKG,GAAMC,IAGNA,EAAI,IALaD,KAUvB,IAAMA,GAAK,EAAGA,GAAK,EAAGA,IACrBH,EAAKG,GAAML,EAAKK,GAEjB,OAAOH,CACR,CAiHSK,CAAUJ,EAAOL,EAAOE,EAAKC,EAAKC,GApG3C,SAAsBC,EAAOL,EAAOE,EAAKC,EAAKC,GAC7C,IAAIG,EACAC,EAGJ,IAAMD,EAAI,EAAGA,EAAIJ,EAAKI,IACrBH,EAAKG,GAAML,EAAKK,GAGjB,IAAMA,EAAIJ,EAAKI,EAAIF,IAClBG,GAAMN,EAAKK,GAAM,GAAMP,EAAOO,GAC9BH,EAAKG,GAAMC,IAGNA,EAAI,IALgBD,KAU1B,IAAMA,GAAK,EAAGA,EAAIF,EAAOE,IACxBH,EAAKG,GAAML,EAAKK,GAEjB,OAAOH,CACR,CAgFQM,CAAaL,EAAOL,EAAOE,EAAKC,EAAKC,EAC7C,CChGA,SAASL,EAAoBC,EAAOC,EAAOC,EAAKC,GAC/C,OAAOQ,EAAQX,EAAOC,EAAOC,EAAKC,EAAKS,EAAOZ,EAAMM,QACrD,CC1BAO,EAAAC,EAAA,SAAAH"}